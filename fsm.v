/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
module DIG_D_FF_1bit
#(
    parameter Default = 0
)
(
   input D,
   input C,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule


module fsm (
  input tp1, tp2, tp3, tp4, tp5,

  input CORRECT1,
  input CORRECT2,
  input EQUAL,
  input K7,
  input K8,
  input K9,
  input VALID,
  input C,
  output CHANGE_UC,
  output IS_PROG_0,
  output IS_PROG_1,
  output LED1_0,
  output LED1_1,
  output LED2_0,
  output LED2_1,
  output LED3_0,
  output LED3_1,
  output LOCK_TOG,
  output RST
);
  wire s0;
  wire \Z_4^n ;
  wire s1;
  wire \Z_1^n ;
  wire \Z_2^n ;
  wire s2;
  wire s3;
  wire s4;
  wire \Z_3^n ;
  wire \Z_0^n ;
  wire s5;
  wire s6;
  wire s7;
  wire s8;
  wire s9;
  wire s10;
  wire s11;
  wire s12;
  wire s13;
  wire s14;
  wire s15;
  wire [4:0] s16;
  assign LED1_0 = 1'b0;
  assign s11 = ~ CORRECT2;
  assign s14 = ~ EQUAL;
  assign s6 = ~ K7;
  assign s8 = ~ K8;
  assign s7 = ~ K9;
  assign s12 = ~ VALID;
  assign s0 = ((CORRECT2 & s1 & \Z_1^n  & \Z_2^n  & s2) | (K8 & s1 & s3 & s4 & \Z_3^n ) | (VALID & \Z_0^n  & s3 & s4 & \Z_3^n ));
  assign s5 = ((EQUAL & \Z_1^n  & s4 & \Z_3^n ) | (s6 & s1 & s3 & \Z_2^n  & s2) | (K8 & s7 & s1 & s3 & s4 & s2) | (s8 & K9 & s1 & s3 & s4) | (K8 & \Z_0^n  & s3 & \Z_2^n  & s2) | (s8 & s1 & s4 & \Z_3^n ) | (s1 & \Z_1^n  & s4 & \Z_3^n ) | \Z_4^n );
  assign s9 = ((~ CORRECT1 & s6 & s1 & \Z_1^n  & s4 & s2 & s10) | (s11 & s1 & \Z_1^n  & \Z_2^n ) | (s6 & s3 & \Z_2^n  & s2) | (s8 & K9 & s1 & s3 & s4 & s2 & s10) | (K8 & s7 & s1 & s3 & s4 & s2 & s10) | (s12 & \Z_0^n  & s4 & \Z_3^n ) | (\Z_0^n  & s3 & \Z_2^n  & s2) | (\Z_0^n  & \Z_1^n  & \Z_3^n ) | (\Z_1^n  & \Z_2^n  & \Z_3^n ));
  assign s13 = ((CORRECT1 & s6 & s1 & \Z_1^n  & s4) | (s11 & s1 & \Z_1^n  & \Z_2^n  & s2) | (s14 & \Z_0^n  & \Z_1^n  & \Z_3^n ) | (s6 & K9 & \Z_0^n  & s3 & s4 & s10) | (K8 & s7 & s1 & s3 & s4 & s2 & s10) | (K8 & \Z_0^n  & s3 & \Z_2^n  & s2) | (\Z_0^n  & s3 & s4 & \Z_3^n ) | (s1 & \Z_1^n  & s4 & \Z_3^n ) | (\Z_0^n  & \Z_1^n  & \Z_2^n  & \Z_3^n ) | (\Z_1^n  & \Z_4^n ));
  assign s15 = ((CORRECT1 & s6 & s1 & \Z_1^n  & s4 & s2 & s10) | (s11 & s1 & \Z_1^n  & \Z_2^n ) | (s14 & \Z_0^n  & \Z_1^n  & s4 & \Z_3^n ) | (s6 & s7 & \Z_0^n  & s3 & s2) | (s6 & \Z_0^n  & s3 & \Z_2^n ) | (s6 & s3 & \Z_2^n  & s2) | (s8 & K9 & s1 & s3 & s4 & s2 & s10) | (K8 & s1 & s4 & \Z_3^n ) | (s12 & \Z_0^n  & s3 & s4 & \Z_3^n ) | (\Z_0^n  & s3 & \Z_2^n  & s2) | (s1 & \Z_1^n  & \Z_2^n  & \Z_3^n ) | (\Z_0^n  & \Z_4^n ));
  // Z_4^n
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i0 (
    .D( s0 ),
    .C( C ),
    .Q( \Z_4^n  )
  );
  // Z_3^n
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i1 (
    .D( s5 ),
    .C( C ),
    .Q( \Z_3^n  )
  );
  // Z_2^n
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i2 (
    .D( s9 ),
    .C( C ),
    .Q( \Z_2^n  )
  );
  // Z_1^n
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i3 (
    .D( s13 ),
    .C( C ),
    .Q( \Z_1^n  )
  );
  // Z_0^n
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i4 (
    .D( s15 ),
    .C( C ),
    .Q( \Z_0^n  )
  );

  assign {tp1, tp2, tp3, tp4, tp5} = { \Z_0^n , \Z_1^n ,  \Z_2^n ,  \Z_3^n ,  \Z_4^n };

  assign RST = ((\Z_0^n  & \Z_2^n  & \Z_3^n ) | (\Z_1^n  & \Z_2^n  & \Z_3^n ) | \Z_4^n );
  assign s10 = ~ \Z_4^n ;
  assign s2 = ~ \Z_3^n ;
  assign s4 = ~ \Z_2^n ;
  assign s3 = ~ \Z_1^n ;
  assign s1 = ~ \Z_0^n ;
  assign s16[0] = \Z_0^n ;
  assign s16[1] = \Z_1^n ;
  assign s16[2] = \Z_2^n ;
  assign s16[3] = \Z_3^n ;
  assign s16[4] = \Z_4^n ;
  assign CHANGE_UC = (s1 & s3 & \Z_2^n  & \Z_3^n );
  assign IS_PROG_0 = ((s1 & \Z_1^n  & \Z_2^n  & s2) | (s1 & s3 & s4 & \Z_3^n ));
  assign IS_PROG_1 = ((\Z_0^n  & s3 & s4 & \Z_3^n ) | (s1 & \Z_1^n  & s4 & \Z_3^n ));
  assign LED2_0 = ((\Z_0^n  & s3 & s4 & s2 & s10) | (s1 & \Z_1^n  & s4 & s2 & s10));
  assign LED3_0 = ((\Z_0^n  & s3 & \Z_2^n  & s2) | (s1 & \Z_1^n  & \Z_2^n  & s2) | (s1 & s4 & \Z_3^n ) | (s1 & s3 & \Z_3^n ) | (s3 & s4 & \Z_3^n ));
  assign LED3_1 = ((\Z_0^n  & \Z_1^n  & \Z_2^n  & s2) | (s1 & s3 & \Z_2^n  & \Z_3^n ));
  assign LOCK_TOG = (\Z_0^n  & \Z_1^n  & s4 & s2);
endmodule
